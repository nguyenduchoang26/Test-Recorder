/**
 * xpath-locator.js - Builds XPath locator strings for DOM elements based on attribute tree.
 * Provides methods to construct robust XPath selectors for identified elements.
 */
/* global document XPathResult */

const locator = {
  /**
   * Construct an XPath expression from the attribute tree for the given element.
   *
   * @param {Array<Object>} tree - Attribute tree generated by tree-builder.
   * @param {HTMLElement} element - Target DOM element.
   * @param {string} type - Classification type of the element.
   * @returns {string} XPath locator string for the element.
   */
  build(tree, element, type) {
    const item = tree[0];
    const tag = Object.keys(item)[0];
    const p = item[tag].reduce(
      (subpath, attr) => (
        subpath === '' ? this._getSubpath(subpath, attr, tag) : subpath
      ),
      ''
    );
    const path = `/${p}`;
    if (!element) return path;
    if (this._found(['@id', '@for'], path)) return path;
    if (this._found(['@name'], path) && this._found(['select'], type)) return path;

    const { count, index } = this._getIndex(path, element);
    return ((count > 1) && (index > 1)) ? `xpath=(${path})[${index}]` : path;
  },

  /**
   * Check if any of the given attribute predicates exist in the path.
   *
   * @param {Array<string>} attributes - List of attribute predicates to find.
   * @param {string} path - Current XPath path string.
   * @returns {boolean} True if any attribute predicate is present.
   */
  _found(attributes, path) {
    return attributes.some(attr => path.includes(attr));
  },

  /**
   * Determine the count and index of matching elements for indexing in XPath.
   *
   * @param {string} path - XPath path to evaluate.
   * @param {HTMLElement} element - Target DOM element.
   * @returns {{count: number, index: number}} Occurrence count and index.
   */
  _getIndex(path, element) {
    let index = 1; // 1 - unique tag
    let count = 1; // 1 - unique element

    let node;
    const nodes = document.evaluate(`.${path}`, document.body, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    while (node = nodes.iterateNext()) {
      if (node === element) { index = count; }
      count += 1;
    }
    return { count, index };
  },

  /**
   * Generate a subpath segment for a single attribute condition.
   *
   * @param {string} subpath - Accumulated XPath subpath.
   * @param {Object} attr - Attribute key-value pair.
   * @param {string} tag - Tag name for the element.
   * @returns {string} XPath segment for this attribute.
   */
  _getSubpath(subpath, attr, tag) {
    if (attr.for != null) return `/${tag}[@for="${attr.for}"]`;
    if ((attr.class != null) && (attr.class.length > 0)) return `/${tag}[@class="${attr.class}"]`;
    if (attr.title != null) return `/${tag}[@title="${attr.title}"]`;
    if (attr.href != null) return `/${tag}[@href="${attr.href}"]`;
    if (attr.name != null) return `/${tag}[@name="${attr.name}"]`;
    if (attr.id != null) return `/${tag}[@id="${attr.id}"]`;
    if (attr.index != null) return `/${tag}`;
    return '';
  }
};

if (typeof exports !== 'undefined') exports.locator = locator;
